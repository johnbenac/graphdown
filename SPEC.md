
# Graphdown Standard: Markdown Dataset Repositories

**Spec Version:** 0.3 (Draft)
**Last Updated:** 2026-01-01
**Status:** Normative / single source of truth

This document is the **only** authoritative specification for Graphdown. It **absorbs** and **replaces** any separate “dataset validity” documents. If there’s a conflict between documents, **this** one wins.

Unless a future version defines otherwise, the canonical hashing procedure described here is **gdhash-v1**.

This version introduces a breaking identity model: records are identified by `(typeId, recordId)` and record links use `[[typeId:recordId]]`.

## Normative language

The keywords **MUST**, **MUST NOT**, **SHALL**, **SHOULD**, **SHOULD NOT**, and **MAY** are to be interpreted as described in RFC-style specs:

* **MUST / SHALL** = required for conformance
* **MUST NOT / SHALL NOT** = forbidden for conformance
* **SHOULD** = recommended, but not strictly required
* **MAY** = optional

---

## Requirement metadata blocks

To make the verification matrix machine-derivable, every requirement heading MUST be preceded by a single-line HTML comment with a stable `id` and `title`.

Format:

```md
<!-- req:id=LAYOUT-001 title="Required directories" -->
### LAYOUT-001 — Required directories
```

Additional attributes MAY be added later (for example `testable=true|false` or `tests="path/to/test"`), but `id` and `title` are mandatory for extraction.

Some governance/process requirements MAY set `testable=false`; these are normative for spec maintenance but are not required to have automated tests.

Attribute semantics:

* `testable=false` — governance/manual only; excluded from coverage gates.
* `testable=true` — **must** have referenced tests; enforced by CI.
* omitted/null — tracked in the matrix but not gated; adding tests is optional.

---

## 0. Governance and change policy

<!-- req:id=GOV-001 title="Spec-first changes" testable=false -->
### GOV-001 — Spec-first changes

Any change that affects externally observable behavior MUST:

* update this spec (normative text),
* update or add tests proving the behavior, and
* update the generated verification matrix to match the spec + tests.

<!-- req:id=GOV-002 title="Verification matrix must match spec" testable=true -->
### GOV-002 — Verification matrix must match spec

The verification matrix artifacts (generated by `tools/spec-trace.cjs`) MUST be derivable from this spec and MUST match the committed `artifacts/spec-trace/matrix.json` and `artifacts/spec-trace/matrix.md` exactly.

---

## 1. Purpose and guiding principles

<!-- req:id=P-001 title="Repository-first, Markdown-canonical" testable=false -->
### P-001 — Repository-first, Markdown-canonical

A Graphdown “Dataset” is a **repository** of Markdown files. **Markdown with YAML front matter is the canonical persistence format**.

* Runtime representations (in-memory graphs, indexes, caches) **MAY** exist.
* **Import/export boundaries are Markdown**, not JSON.

<!-- req:id=P-002 title="Dataset defines the model" testable=false -->
### P-002 — Dataset defines the model

A Dataset contains **both**:

* the **data** (records), and
* the **data model** (types/schema-as-data)

No “per-dataset code” is allowed as a requirement for basic use.

<!-- req:id=P-003 title="Universality and minimal assumptions" testable=false -->
### P-003 — Universality and minimal assumptions

Graphdown is a universal CRUD + navigation engine.

* The core **MUST NOT** embed assumptions about domain schemas.
* The core **MUST** remain usable when encountering novel or arbitrary schemas.

---

## 2. Explicit non-requirements

These are not “maybe later” notes; they are **out of scope by design**, to prevent hidden second standards.

<!-- req:id=NR-UI-001 title="No standardized UI hints" testable=false -->
### NR-UI-001 — No standardized UI hints

This standard defines no standardized “UI hints” keys, formats, or semantics inside `fields`.

Datasets MAY include arbitrary UI-hint-like keys inside `fields` (e.g. `ui`, `widget`, `label`), but core behavior MUST NOT depend on them and will ignore them.

<!-- req:id=NR-UI-002 title="UI hint keys are ignored by core validation" testable=true -->
### NR-UI-002 — UI hint keys are ignored by core validation

Core validation MUST treat all non-reserved keys inside `fields` as opaque, including keys commonly used as UI hints (e.g. `ui`, `widget`, `label`).
Datasets MUST NOT be rejected due to the presence, absence, or shape of such keys.

(Plugins MAY interpret any dataset content; that is explicitly out-of-scope of core.)

<!-- req:id=NR-SEM-001 title="No semantic validation of fields" testable=true -->
### NR-SEM-001 — No semantic validation of fields

Core validation MUST NOT reject records based on semantic interpretation of `fields` values (e.g. enforcing booleans, dates, money objects, enums, or format constraints), regardless of any metadata present in type objects (including keys inside `fields.fieldDefs`).

If you want those semantics, that’s plugin territory (or dataset-author tooling), not core.

<!-- req:id=NR-SEC-001 title="No security hardening requirement" testable=false -->
### NR-SEC-001 — No security hardening requirement

This standard does not require defenses against malicious datasets (e.g., injection attempts). The spec is about interoperability and determinism, not adversarial threat models.

<!-- req:id=NR-LINK-001 title="No requirement that links resolve" -->
### NR-LINK-001 — No requirement that links resolve (except composition constraints)

Wiki-links MAY point to non-existent record references `typeId:recordId` (Obsidian-style “uncreated” notes). Unresolved links are not an import-failing error.

Exception: unresolved links **do not** satisfy composition constraints (VAL-COMP-002). Import MUST fail when composition requirements are unmet.

---

## 3. Terminology

### Dataset

A **Dataset** is a Graphdown dataset/repository instance.

### Type object

A **type object** is a record file whose YAML front matter defines a type (FR-MD-021).

### Record object

A **record object** is a record file whose YAML front matter defines a record instance (FR-MD-023).

### typeId

Stable identifier for a type object.

### recordId

Stable identifier for a record object **within its type**.

### recordKey (computed)

`typeId:recordId` — the globally unique record identity. Core treats `recordKey` as computed and MUST NOT store it as a separate YAML field.

### Record reference

A string equal to `recordKey`, used inside wiki-links.

### Wiki-link

Obsidian-style link syntax: `[[...]]` containing a record reference `typeId:recordId`.

---

<!-- req:id=ID-001 title="Identifier syntax is separator-safe" testable=true -->
### ID-001 — Identifier syntax is separator-safe

`typeId` and `recordId` MUST be strings and MUST be non-empty after trimming.

`typeId` MUST match: `^[A-Za-z0-9][A-Za-z0-9_-]*$`

`recordId` MUST match: `^[A-Za-z0-9][A-Za-z0-9_-]*$`

`typeId` and `recordId` MUST NOT contain `:`.
Colon is reserved as the separator in `typeId:recordId` record references.

---

## 3.1 Dataset identity hashes

A Dataset’s identity is computed from its record files, not from any human-managed dataset record.
This standard defines two computed identity values:

* **Schema fingerprint**: based on type objects only
* **Snapshot fingerprint**: based on type objects + record objects

No “records-only” fingerprint is defined in core.

<!-- req:id=HASH-001 title="Canonical dataset hashing (gdhash-v1)" -->
### HASH-001 — Canonical dataset hashing (gdhash-v1)

Core implementations MUST be able to compute deterministic hashes over Graphdown record files.

1. **Discover included record files**
   * Record files are discovered per LAYOUT-001.

2. **Normalize each included record file**
   For each included record file:
   * Read the entire file as bytes.
   * Decode as UTF-8 text. Import MUST fail if UTF-8 decoding fails.
   * For hashing only, normalize line endings by converting all `\r\n` and bare `\r` to `\n`.
   * Parse YAML front matter (FR-MD-020/021/023). Import MUST fail if parsing fails or the YAML does not form a valid type object or record object.
   * Determine the identity string:
     * type objects: `identity = typeId`
     * record objects: `identity = typeId:recordId`
   * If two included record files share the same identity string, hashing MUST fail.

3. **Sort**
   Sort included records by the UTF-8 bytes of the identity string in ascending lexicographic order.

4. **Build the byte stream**
   Build the byte stream to hash as:

   * prefix: the UTF-8 bytes of the literal string `graphdown:gdhash:v1` followed by a single NUL byte (`0x00`)
   * then, for each record in sorted order, append:

     * the identity string as UTF-8 bytes, then NUL (`0x00`)
     * the decimal byte length of the normalized file content (ASCII digits), then NUL (`0x00`)
     * the normalized file content bytes
     * NUL (`0x00`)

5. **Digest**
   Compute `SHA-256` over the resulting byte stream.

The resulting digest MUST be encoded as lowercase hexadecimal.

<!-- req:id=HASH-002 title="Schema fingerprint (types only)" -->
### HASH-002 — Schema fingerprint (types only)

Implementations MUST compute a **schema fingerprint** for a dataset.

The schema fingerprint is the gdhash-v1 SHA-256 digest computed over **all type objects** (FR-MD-021), and over no other files.

<!-- req:id=HASH-003 title="Snapshot fingerprint (types + record objects)" -->
### HASH-003 — Snapshot fingerprint (types + record objects)

Implementations MUST compute a **snapshot fingerprint** for a dataset.

The snapshot fingerprint is the gdhash-v1 SHA-256 digest computed over **all type objects (FR-MD-021) and all record objects (FR-MD-023)**.

<!-- req:id=HASH-004 title="Only schema and snapshot fingerprints are defined in core" testable=true -->
### HASH-004 — Only schema and snapshot fingerprints are defined in core

Graphdown core defines exactly two standardized dataset fingerprint computations:

* schema fingerprint (HASH-002)
* snapshot fingerprint (HASH-003)

Core MUST NOT define or expose any additional standardized fingerprint computation.

If the core hashing API accepts a `scope` selector, it MUST accept only `schema` and `snapshot`.
Any other value MUST fail with error code `E_USAGE` and MUST NOT return a digest.

## 4. Repository layout requirements

<!-- req:id=LAYOUT-001 title="Record files are discovered by content (not path)" testable=true -->
### LAYOUT-001 — Record files are discovered by content (not path)

A **record file** is any file that:

* ends in `.md`,
* begins with YAML front matter at byte 0 (the first three bytes are `---` followed by a line break), and
* whose parsed YAML object contains a `typeId` key.

Files that do not meet these conditions are ignored by core. Paths and directory names carry no semantic meaning and MUST NOT affect validity, identity, or hashing.

<!-- req:id=LAYOUT-002 title="One object per file" testable=true -->
### LAYOUT-002 — One object per file

Each record file MUST contain exactly one YAML front matter block at the start of the file (per FR-MD-020). The remainder of the file is the record body (FR-MD-022).

Core MUST NOT support multiple record objects in a single file.

---

## 5. Markdown record file format

<!-- req:id=FR-MD-020 title="YAML front matter is required" -->
### FR-MD-020 — YAML front matter is required

Every record file **MUST** start with YAML front matter delimited by:

```md
---
<yaml object>
---
<body markdown>
```

Import/validation **MUST** fail if:

* front matter is missing,
* YAML is invalid, or
* YAML parses to a non-object (array/string/null).

<!-- req:id=FR-MD-021 title="Required top-level keys for type objects" testable=true -->
### FR-MD-021 — Required top-level keys for type objects

A YAML front matter object is a **type object** when it defines:

* `typeId` (string; MUST satisfy ID-001)
* `fields` (object/map)

A type object MUST NOT define `recordId`.

A type object MUST NOT define any other top-level keys.

<!-- req:id=FR-MD-023 title="Required top-level keys for record objects" testable=true -->
### FR-MD-023 — Required top-level keys for record objects

A YAML front matter object is a **record object** when it defines:

* `typeId` (string; MUST satisfy ID-001)
* `recordId` (string; MUST satisfy ID-001)
* `fields` (object/map)

A record object MUST NOT define any other top-level keys.

<!-- req:id=FR-MD-022 title="Body is raw Markdown" -->
### FR-MD-022 — Body is raw Markdown

The record body is everything after the closing `---`. It is raw Markdown and MAY be empty.

Core MUST treat the body as an uninterpreted string (except for link extraction; see §8).

---

## 6. Reserved keys and extensibility rules

<!-- req:id=EXT-001 title="Top-level vocabulary is fixed" testable=true -->
### EXT-001 — Top-level vocabulary is fixed

The only top-level YAML keys defined by this standard are:

* `typeId`
* `recordId`
* `fields`

All other top-level keys are forbidden.

<!-- req:id=EXT-002 title="`fields` is open" -->
### EXT-002 — `fields` is open

`fields` MAY contain any YAML value shapes:

* scalars (string/number/bool/null)
* arrays
* objects/maps
* arbitrarily nested structures

Core MUST NOT reject records because `fields` contains unfamiliar structures.

---

## 7. Types and schema-as-data

<!-- req:id=TYPE-001 title="Types are defined by type objects" testable=true -->
### TYPE-001 — Types are defined by type objects

A dataset’s schema is defined by its type objects (FR-MD-021). Each type object defines exactly one type via its `typeId`.

<!-- req:id=TYPE-002 title="typeId uniqueness" testable=true -->
### TYPE-002 — typeId uniqueness

`typeId` values across all type objects MUST be globally unique.

<!-- req:id=TYPE-004 title="fieldDefs shape" testable=true -->
### TYPE-004 — fieldDefs shape

A type object is valid with or without `fields.fieldDefs`.

When present, `fields.fieldDefs` MUST be a map keyed by field name. Each field definition value MUST be an object.

Core recognizes exactly one standard key inside a field definition object:

* `required` (boolean)

All other keys inside field definition objects are allowed and MUST be treated as opaque by core.

<!-- req:id=TYPE-COMP-001 title="composition shape" testable=true -->
### TYPE-COMP-001 — composition shape

A type object is valid with or without `fields.composition`.

When present, `fields.composition` MUST be a map keyed by component name.
Each component value MUST be an object that defines:

* `typeId` (string; MUST satisfy ID-001)
* `required` (boolean)

All other keys inside component objects are forbidden.

---

## 8. Relationships and linking

<!-- req:id=REL-001 title="Record relationships use composite wiki-links" testable=true -->
### REL-001 — Record relationships use composite wiki-links

A record-to-record relationship is expressed only as a wiki-link token of the form:

`[[typeId:recordId]]`

Both `typeId` and `recordId` inside the token MUST satisfy ID-001.

<!-- req:id=REL-002 title="Where record relationships are extracted" testable=true -->
### REL-002 — Where record relationships are extracted

Core MUST extract record relationship targets from:

* the record body, and
* any string value anywhere within the record `fields` map (including nested objects/arrays).

Core MUST NOT extract relationships from type objects.

<!-- req:id=REL-003 title="Record reference normalization" testable=true -->
### REL-003 — Record reference normalization

When interpreting a wiki-link token, core MUST:

* unwrap `[[...]]`
* trim surrounding whitespace
* require the inner text to match `typeId:recordId` where both parts satisfy ID-001

Tokens that do not match this shape MUST be ignored for relationship extraction.

<!-- req:id=REL-004 title="Preservation: do not rewrite link spellings" testable=false -->
### REL-004 — Preservation: do not rewrite link spellings

Core implementations **MUST NOT** rewrite user-authored link spellings during import/export, including:

* converting `[[typeId:recordId]]` → `typeId:recordId`
* converting bare strings → `[[typeId:recordId]]`
* “normalizing” casing, punctuation, or whitespace inside stored text

Relationships are extracted for graph behavior, but the stored bytes are treated as user-authored text. (See EXP-005 for the export conformance rule.)

<!-- req:id=REL-005 title="Graphdown-created relationships are serialized as wiki-links" testable=true -->
### REL-005 — Graphdown-created relationships are serialized as wiki-links

When Graphdown creates a relationship through its editing API/UI, it MUST serialize the relationship using wiki-link syntax `[[typeId:recordId]]` in the persisted Markdown content.

<!-- req:id=REL-007 title="Only composite wiki-links are relationships in core" testable=true -->
### REL-007 — Only composite wiki-links are relationships in core

Core MUST recognize relationships only from wiki-link tokens `[[typeId:recordId]]`.

Core MUST NOT infer relationships from structured YAML shapes, bare IDs, or any other conventions.

Such shapes MAY exist as opaque user data per EXT-002, but they have no relationship semantics in core.

---

## 9. Import-time validity and integrity rules

<!-- req:id=VAL-001 title="Type/records must be internally consistent" -->
### VAL-001 — Type/records must be internally consistent

Import MUST fail if:

* any record file fails record format requirements (§5)
* any type object fails type requirements (§7)
* identity uniqueness fails (§9.2)
* a record object’s `typeId` has no matching type object (§9.3)

<!-- req:id=VAL-002 title="Identity uniqueness rules" testable=true -->
### VAL-002 — Identity uniqueness rules

Type identity:
* `typeId` values across type objects MUST be unique (TYPE-002).

Record identity:
* For record objects, the pair `(typeId, recordId)` MUST be unique across the dataset.

`recordId` alone is not required to be unique globally.

<!-- req:id=VAL-003 title="Record objects must reference an existing type" testable=true -->
### VAL-003 — Record objects must reference an existing type

For every record object, its `typeId` MUST match exactly one type object `typeId`.
Validation MUST fail otherwise.

<!-- req:id=VAL-005 title="Required fields (schema-driven)" -->
### VAL-005 — Required fields (schema-driven)

When a type object defines `fields.fieldDefs`, then for every field definition where `required: true`:

* every record object of that `typeId` MUST contain `fields.<fieldName>` with a value that is not:

  * missing,
  * null,
  * or an all-whitespace string.

(For arrays/objects, “empty” is not defined as invalid by core; only missing/null/blank-string is.)

<!-- req:id=VAL-006 title="No semantic validation of values" -->
### VAL-006 — No semantic validation of values

Beyond VAL-005, core MUST NOT validate field values against:

* kind semantics,
* constraints,
* enum option sets,
* number ranges,
* date formats,
* money shapes, etc.

Those are not validity rules in this standard.

<!-- req:id=VAL-COMP-001 title="Composition referenced types must exist" -->
### VAL-COMP-001 — Composition referenced types must exist

When a type object defines `fields.composition`, every referenced component `typeId` MUST match an existing type object. Validation MUST fail otherwise.

<!-- req:id=VAL-COMP-002 title="Required components must be satisfied by outgoing record links" -->
### VAL-COMP-002 — Required components must be satisfied by outgoing record links

When a type object defines `fields.composition`, then for every record object of that `typeId`:

For each component where `required: true`, the record MUST contain at least one outgoing relationship link (REL-001/REL-002/REL-003) to an existing record object whose `typeId` equals the component `typeId`.

Links that do not resolve to an existing record object do not satisfy composition.

---

## 10. Error reporting requirements

<!-- req:id=ERR-001 title="File-specific errors when possible" -->
### ERR-001 — File-specific errors when possible

Validators/importers MUST report errors with:

* the file path (when applicable), and
* a stable error code, and
* a human-readable message.

<!-- req:id=ERR-002 title="Clear failure categories for GitHub import" -->
### ERR-002 — Clear failure categories for GitHub import

UI MUST differentiate at least:

* invalid URL format
* repo not found (404)
* private/auth required (401/403)
* rate limited (403 + hint)
* dataset invalid (structural/validation errors)

---

## 11. Import from GitHub requirements

<!-- req:id=GH-001 title="Supported URL forms" -->
### GH-001 — Supported URL forms

Import MUST accept:

* `github.com/<owner>/<repo>`
* `https://github.com/<owner>/<repo>`
* `github.com/<owner>/<repo>/tree/<ref>`

<!-- req:id=GH-002 title="Default ref resolution" -->
### GH-002 — Default ref resolution

If no ref is provided, importer MUST use the repository default branch (fallback to `main` if unavailable).

<!-- req:id=GH-003 title="Recursive listing + raw fetch" -->
### GH-003 — Recursive listing + raw fetch

Importer MUST:

* list files recursively via GitHub tree API (`?recursive=1`)
* fetch contents via `raw.githubusercontent.com`

<!-- req:id=GH-005 title="Reject subdirectory URLs" -->
### GH-005 — Reject subdirectory URLs

Importer **MUST** reject URLs that specify a subdirectory after `/tree/<ref>/` and instruct users to import from the repository root.

<!-- req:id=GH-008 title="Public repo import requires no auth" -->
### GH-008 — Public repo import requires no auth

Unauthenticated import from public repositories MUST work for MVP.

---

## 12. Export requirements

Export produces repository snapshots as files (not a JSON/database dump). Graphdown record files remain
Markdown with YAML front matter per §5 and are intended to be tracked in version control.

<!-- req:id=EXP-002 title="Record-only export" -->
### EXP-002 — Record-only export

Export MUST support exporting the Graphdown record subset:

* all type objects (FR-MD-021)
* all record objects (FR-MD-023)

as a zip archive.

<!-- req:id=EXP-003 title="Whole-repo export" -->
### EXP-003 — Whole-repo export

Export MUST support exporting the entire repository snapshot (including non-record files) as a zip archive.

<!-- req:id=EXP-004 title="Path stability" -->
### EXP-004 — Path stability

When exporting files that were imported from specific paths, export SHOULD preserve those paths (unless the user explicitly relocates files). Paths carry no semantic meaning but may be preserved for user convenience.

<!-- req:id=EXP-005 title="Content preservation (no “reformat the universe”)" -->
### EXP-005 — Content preservation (no “reformat the universe”)

Export MUST NOT rewrite record content merely to “normalize” it, including:

* rewriting wiki-links (§8)
* reformatting YAML keys or changing scalar spellings
* rewrapping strings / changing quotes

Graphdown should only change what the user actually edited.

---

## 13. UI requirements

<!-- req:id=UI-001 title="Desktop + mobile usable" testable=false -->
### UI-001 — Desktop + mobile usable

UI shall be usable on desktop and mobile form factors (non-testable intent).

<!-- req:id=UI-004 title="Consistent CRUD + relationship affordances" testable=false -->
### UI-004 — Consistent CRUD + relationship affordances

UI shall provide consistent CRUD + relationship affordances (non-testable intent).

<!-- req:id=NFR-001 title="No full reloads for CRUD" testable=true -->
### NFR-001 — CRUD does not perform full document reloads

In the Graphdown web UI, performing CRUD actions MUST NOT trigger a full document navigation/reload.
Specifically, after the initial page load, CRUD actions MUST NOT cause the top-level document `load` event to fire again.

<!-- req:id=NFR-010 title="Read-only offline after initial load" testable=true -->
### NFR-010 — Read-only offline after initial load

After a dataset is loaded, the UI MUST allow read-only navigation of already-loaded records while the browser is offline.

<!-- req:id=UI-RAW-001 title="Schema-agnostic record editor" testable=true -->
### UI-RAW-001 — Schema-agnostic record editor

The UI MUST provide a single, schema-agnostic editor that works without plugins and without interpreting type schema beyond `required`.

The editor MUST let the user:

* create/edit the record `recordId` (on create),
* edit the record `fields` as a YAML map (key/value data),
* edit the record Markdown body as raw text.

The editor MUST NOT require any semantic understanding of field kinds (e.g., number/date/ref) to render or save edits. Optional UI conveniences are allowed, but they MUST NOT be required for CRUD.

On save, the UI MUST validate the resulting dataset snapshot using core validation rules. If validation fails, the UI MUST NOT persist the change and MUST surface the validation errors.

---

## 14. Plugin and extensibility requirements

<!-- req:id=NFR-030 title="Plugins must not require core modification" testable=false -->
### NFR-030 — Plugins must not require core modification

The system shall be structured so plugins do not require modifying core code.

<!-- req:id=NFR-031 title="New field kinds without rewriting CRUD" testable=false -->
### NFR-031 — New field kinds without rewriting CRUD

New schema shapes shall be addable without rewriting the CRUD engine.

This means:

* core MUST treat field definition keys as opaque beyond `required` (§7)
* CRUD MUST remain possible without plugins (UI-RAW-001)

Plugins MAY:

* interpret kinds,
* interpret arbitrary metadata (including UI-hint-like keys),
* provide nicer editors/renderers/validators,
* add alternative navigation or views,

…but core MUST remain correct without them.

---

## 15. System-level acceptance criteria

A build is acceptable when:

1. A user can define a new Type with fields in the model editor.
2. That Type automatically appears in navigation.
3. A user can create, edit, and delete records of that Type.
4. A user can define a relationship and link records accordingly (wiki-link semantics).
5. A user can export the Dataset, re-import it, and all records + relationships + views are intact.
6. Adding a new Type requires **zero code changes** to be usable via CRUD and navigation.

---

## Appendix A. Minimal examples

### Type object (composition + required fields)

```md
---
typeId: car
fields:
  fieldDefs:
    vin:
      required: true
    trim:
      required: false
  composition:
    engine:
      typeId: engine
      required: true
    roof_rack:
      typeId: roof_rack
      required: false
---
```

### Record object (links satisfy composition)

```md
---
typeId: car
recordId: car-001
fields:
  vin: "123"
  trim: sport
---
Has engine [[engine:e-9]].
